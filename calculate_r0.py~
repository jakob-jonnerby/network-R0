import numpy as np
from graph_tool.generation import price_network, geometric_graph
from graph_tool import infect_vertex_property
from graph_tool.dynamics import SIRSState
import matplotlib.pyplot as plt
from graph_tool.all import *
from numpy.random import *
import sys, os, os.path

SUSCEPTIBLE = 0
INFECTED = 1
RECOVERED = 2

print('Imported all libraries')


def SIRmodel(g, state, SIRS_params):
    beta = SIRS_params['beta']
    gamma = SIRS_params['gamma']
    vxs = list(g.vertices())
    patient_zero = np.nonzero(state.a)[0][0]
    infection_log = 0
    while state[patient_zero] == INFECTED:
        shuffle(vxs)
        for v in vxs:
            if state[v] == INFECTED:
                if random() < gamma:
                    state[v] = RECOVERED
                    if v == patient_zero:
                        break
            elif state[v] == SUSCEPTIBLE:
                ns = list(v.out_neighbors())
                for w in ns:
                    if state[w] == INFECTED:
                        if random() < beta:
                            state[v] = INFECTED
                            if w == patient_zero:
                                infection_log += 1
                            break
                
    return infection_log


def calculate_R0(g, SIRS_params):
    vxs = g.get_vertices()    
    # Pick one person uniformly at random
    k_selection = np.random.choice(vxs, 1, replace=False)
    if len(g.get_out_neighbours(k_selection)) == 0:
        R0 = 0
    else:
        # Pick one neighbour at random
        k_neighbour = np.random.choice(g.get_out_neighbours(k_selection))
        # vertex property map that stores state of individuals in model
        state = g.new_vertex_property('int32_t', False)
        state.a[k_neighbour] = 1  # infect all people in k_neighbours
        # Create vertex property map to encode who to filter out
        new_vxs = state.copy(value_type='bool')
        # Include all neighbours of people in new_vxs
        infect_vertex_property(g, new_vxs, vals=[True])
        # Remove all vertices not in new_vxs
        g.set_vertex_filter(new_vxs)
        # Initialise model with correct state
        R0 = SIRmodel(g, state, SIRS_params)
    return R0


def calculate_beta(R0, gamma):
    """
    Computes (an estimate of) the beta value required to achieve R0 value,
    given gamma value as input.
    
    See http://mathb.in/41156?key=4015f0a16bda5a594d4f3661ca7b65fd00f7a975
    for details.
    """
    return (R0 * gamma) / (2 + (gamma-1)*R0)


if __name__ == "__main__":
    n = 10**5  # population size
    # k = 1
    trials = 100
    SIRS_params = {'beta': 0.01,
                   'gamma': 0.0476,
                   'mu': 0,
                   'exposed': False,
                   'epsilon': 0,
                   'v0': None,
                   'constant_beta': True
                   }
    R0_trials = np.zeros(trials)
    for i in range(trials):
        print(i)
        # SCALE-FREE NETWORK
        # g = price_network(n, directed=False, m=2)

        # RANDOM GEOMETRIC NETWORK
        points = np.random.random((n, 2)) * 5
        g, pos = geometric_graph(points, 0.05, [(0,4), (0,4)])
        R0_trials[i] = calculate_R0(g, SIRS_params)

    print(np.mean(R0_trials))
    print(np.std(R0_trials))
    plt.hist(R0_trials, bins=np.linspace(0, 10, 100))
    plt.show()
